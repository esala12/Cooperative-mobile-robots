#!/usr/bin/env python3

import rospy
from std_msgs.msg import Float64
from nav_msgs.msg import Odometry, Path
from geometry_msgs.msg import Twist
from visualization_msgs.msg import Marker
import numpy as np
import math

class TargetVelocityController:
    def __init__(self):
        self.distance_master = rospy.get_param('~distance_master', 1.5)
        self.forward_slave_goal = rospy.get_param('~forward_slave_goal', True)

        # Subscribe to the path topic generated by another node
        self.path_sub = rospy.Subscriber('/generated_path', Path, self.path_callback)
        self.rate = rospy.Rate(10)  # 10 Hz

        # Initialize variables for path and goals
        self.path = None
        self.reached_final_waypoint = False
        self.distance_flag = False
        self.distance_to_goal = 0.0
        master_pos = np.array([self.distance_master, 0])
        self.goal_master = [self.distance_master, 0.0]

        self.reached_final_waypoint_slave = False
        self.distance_flag_slave = False
        self.goal_slave = [0.0, 0.0]

        self.master_filter_x = 0.0
        self.master_filter_y = 0.0
        self.slave_filter_x = 0.0
        self.slave_filter_y = 0.0

        # Publishers for master
        self.master_error_x_pub = rospy.Publisher('error_master_x', Float64, queue_size=1)
        self.master_input_linear_x_vel_pub = rospy.Publisher('input_linear_master_x_vel', Float64, queue_size=1)
        self.master_error_y_pub = rospy.Publisher('error_master_y', Float64, queue_size=1)
        self.master_input_linear_y_vel_pub = rospy.Publisher('input_linear_master_y_vel', Float64, queue_size=1)
        self.master_vel_pub = rospy.Publisher('master_cmd_vel', Twist, queue_size=10)
        self.master_goal_marker_pub = rospy.Publisher('master_goal_marker', Marker, queue_size=10)

        # Publishers for slave
        self.slave_error_x_pub = rospy.Publisher('error_slave_x', Float64, queue_size=1)
        self.slave_input_linear_x_vel_pub = rospy.Publisher('input_linear_slave_x_vel', Float64, queue_size=1)
        self.slave_error_y_pub = rospy.Publisher('error_slave_y', Float64, queue_size=1)
        self.slave_input_linear_y_vel_pub = rospy.Publisher('input_linear_slave_y_vel', Float64, queue_size=1)
        self.slave_vel_pub = rospy.Publisher('slave_cmd_vel', Twist, queue_size=10)
        self.slave_goal_marker_pub = rospy.Publisher('slave_goal_marker', Marker, queue_size=10)

    def path_callback(self, path_msg):
        """Callback to receive the generated path from another node."""
        self.path = np.array([[pose.pose.position.x, pose.pose.position.y] for pose in path_msg.poses])
        self.update_master_and_slave_goals()

    def update_master_and_slave_goals(self):
        """Update goals for master and slave robots based on the received path."""
        if self.path is None:
            rospy.logwarn("Path not received yet.")
            return

        # Initialize master and slave positions
        master_pos = np.array([self.master_filter_x, self.master_filter_y])
        distances = np.linalg.norm(self.path - master_pos, axis=1)
        self.count_master = np.argmin(distances)

        # Update master goal
        self.update_goal_master(self.master_filter_x, self.master_filter_y)

        # Update slave goal
        self.update_goal_slave()

    def update_goal_master(self, distance_x, distance_y):
        """Update the master robot's goal."""
        end_of_path = self.path[-1]
        distance_to_end = math.sqrt((end_of_path[0] - distance_x) ** 2 + (end_of_path[1] - distance_y) ** 2)

        if self.forward_slave_goal and distance_to_end <= self.distance_master:
            rospy.loginfo("Master is within distance_master of the end of the path. Keeping current goal.")
            self.reached_final_waypoint = True
            return

        while not self.reached_final_waypoint and not self.distance_flag:
            if self.count_master >= len(self.path):
                self.reached_final_waypoint = True
                self.goal_master = self.path[-1]
                break

            x_val, y_val = self.path[self.count_master]
            distance_to_point = math.sqrt((x_val - distance_x) ** 2 + (y_val - distance_y) ** 2)

            if distance_to_point >= 0.1:
                self.goal_master = [x_val, y_val]
                self.distance_flag = True
                self.publish_goal_marker(self.goal_master, self.master_goal_marker_pub, "master_goal_marker", 0, (1.0, 0.0, 0.0))
            else:
                self.count_master += 1

        if self.distance_to_goal < 0.1:
            self.distance_flag = False

    def update_goal_slave(self):
        """Update the slave robot's goal."""
        if self.path is None:
            return

        x_master, y_master = self.goal_master
        master_index_array = np.where((self.path == self.goal_master).all(axis=1))[0]
        if len(master_index_array) == 0:
            rospy.logwarn("Master index not found in path")
            return
        master_index = master_index_array[0]

        if self.forward_slave_goal:
            # Look forward in the path for the slave goal
            for i in range(master_index + 1, len(self.path)):
                x, y = self.path[i]
                distance = math.sqrt((x - x_master) ** 2 + (y - y_master) ** 2)
                if abs(distance - self.distance_master) < 0.01:
                    self.goal_slave = [x, y]
                    self.distance_flag_slave = True
                    self.publish_goal_marker(self.goal_slave, self.slave_goal_marker_pub, "slave_goal_marker", 1, (0.0, 0.0, 1.0))
                    break
        else:
            # Look backward in the path for the slave goal
            for i in range(master_index - 1, -1, -1):
                x, y = self.path[i]
                distance = math.sqrt((x - x_master) ** 2 + (y - y_master) ** 2)
                if abs(distance - self.distance_master) < 0.01:
                    self.goal_slave = [x, y]
                    self.distance_flag_slave = True
                    self.publish_goal_marker(self.goal_slave, self.slave_goal_marker_pub, "slave_goal_marker", 1, (0.0, 0.0, 1.0))
                    break

        if not self.distance_flag_slave:
            rospy.logwarn("No valid slave goal found within criteria")
            self.distance_flag_slave = False

    def odom_master_callback(self, msg):
        """Callback for receiving master's odometry data."""
        self.master_filter_x = msg.pose.pose.position.x
        self.master_filter_y = msg.pose.pose.position.y
        self.update_master_and_slave_goals()

    def odom_slave_callback(self, msg):
        """Callback for receiving slave's odometry data."""
        self.slave_filter_x = msg.pose.pose.position.x
        self.slave_filter_y = msg.pose.pose.position.y
        self.update_goal_slave()

    def vel_x_master_callback(self, msg):
        self.master_linear_x_out = msg.data
        self.publish_velocity_master()

    def vel_y_master_callback(self, msg):
        self.master_linear_y_out = msg.data
        self.publish_velocity_master()

    def vel_x_slave_callback(self, msg):
        self.slave_linear_x_out = msg.data
        self.publish_velocity_slave()

    def vel_y_slave_callback(self, msg):
        self.slave_linear_y_out = msg.data
        self.publish_velocity_slave()

    def publish_velocity_master(self):
        master_vel_out = Twist()
        master_vel_out.linear.x = getattr(self, 'master_linear_x_out', 0.0)
        master_vel_out.linear.y = getattr(self, 'master_linear_y_out', 0.0)
        self.master_vel_pub.publish(master_vel_out)

    def publish_velocity_slave(self):
        slave_vel_out = Twist()
        slave_vel_out.linear.x = getattr(self, 'slave_linear_x_out', 0.0)
        slave_vel_out.linear.y = getattr(self, 'slave_linear_y_out', 0.0)
        self.slave_vel_pub.publish(slave_vel_out)

    def publish_goal_marker(self, goal, publisher, ns, id, color):
        marker = Marker()
        marker.header.frame_id = "map"
        marker.header.stamp = rospy.Time.now()
        marker.ns = ns
        marker.id = id
        marker.type = Marker.CYLINDER
        marker.action = Marker.ADD
        marker.pose.position.x = goal[0]
        marker.pose.position.y = goal[1]
        marker.pose.position.z = 0.0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0
        marker.scale.x = 0.1
        marker.scale.y = 0.1
        marker.scale.z = 0.01
        marker.color.a = 1.0
        marker.color.r = color[0]
        marker.color.g = color[1]
        marker.color.b = color[2]
        publisher.publish(marker)

if __name__ == '__main__':
    rospy.init_node('leader_switch_node')

    fuzzy_controller = TargetVelocityController()

    # Subscribers for master
    rospy.Subscriber('masterbot_kalman', Odometry, fuzzy_controller.odom_master_callback)
    rospy.Subscriber('output_linear_master_x_vel', Float64, fuzzy_controller.vel_x_master_callback)
    rospy.Subscriber('output_linear_master_y_vel', Float64, fuzzy_controller.vel_y_master_callback)
    rospy.Subscriber('master_filter', Odometry, fuzzy_controller.odom_master_callback)

    # Subscribers for slave
    rospy.Subscriber('slavebot_kalman', Odometry, fuzzy_controller.odom_slave_callback)
    rospy.Subscriber('output_linear_slave_x_vel', Float64, fuzzy_controller.vel_x_slave_callback)
    rospy.Subscriber('output_linear_slave_y_vel', Float64, fuzzy_controller.vel_y_slave_callback)
    rospy.Subscriber('slave_filter', Odometry, fuzzy_controller.odom_slave_callback)

    rospy.spin()
